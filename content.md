# SAST.2026 C语言急救车

## 上车须知

- 对于今后有志从事计算机相关行业的同学
  - 若不能 80 分以上，建议重修
- 本课程仅面向考试
  - 某些内容可能不尽合理
- 本课程的主题是急救
  - 可能不会涉及复杂题目，但并非说某些题不重要，看你自己的取舍吧
- 计软院、物联网学院等专业试卷题型不一样
  - 开卷考试+手写代码，需要对 C 语言有更深入的理解
- 每个专业考点可能不同
  - 有选择地理解记忆知识点

**资料来源：** 实验指导 / 校 C 语言平台 / 科协祖传

**观看回放以及往年录播请访问 南邮校科协 B 站账号**

---

## 第一章：计算机、C 语言与二进制

**重点：**

- 冯诺伊曼架构
- 进制转换

**难点：**

- 源程序到目标程序的翻译方式
- 内存及储存容量相关概念

### 冯诺伊曼架构：常识题，考前抢记即可

1. 冯诺伊曼提出了**程序存储**的思想。
2. 计算机的五大基本组成部件：**运算器、控制器、存储器、输入设备、输出设备**。

### 进制转换：记住算法，理解最好

#### 1. 二进制转 k 进制

如果 k 不是 4, 8, 16：先转成十进制，然后再从十进制转成 k 进制

- **第一步：** 二进制 转 十进制
- **第二步：** 十进制 转 k 进制

#### 2. 有关八进制和十六进制

先转成二进制：

- 一个八进制位相当于**三个**二进制位
- 一个十六进制位相当于**四个**二进制位

### 源程序到目标程序的翻译方法

只有三种：**汇编，编译，解释**。C 语言使用的是**编译**。

### 内存

关于内存的问题，记住两个点：

1. **32 位操作系统最多支持 4G 内存**
   - 即 32 根地址总线，每根总线上两种状态 0 或 1，那么就可以有 2³² 个地址。

2. **存储单位换算**

   ```
   1 B = 8 bit
   1 KB = 1024 B
   1 MB = 1024 KB
   1 GB = 1024 MB
   1 TB = 1024 GB
   ```

   > **Tips：** 1024 是 2 的 10 次方

---

## 第二章：源程序和数据类型

**重点：**

- 函数是 C 语言源程序的基本单位（会考选择题）
- 变量命名规范
- 基本数据类型，变量和常量
- scanf / printf
- getchar / putchar

**难点：**

- 基本类型的输入输出控制方法

### 命名规则（附录 G）

1. 只能由**字母、数字、下划线**组成。
2. 开头只能是**字母或者下划线**。
3. 不能与**保留字**（附录 B）或者**库函数**冲突。

### 考察点

- P23 表格：实型常量的表示方式
- P23 表格：常用的转义字符
- 单引号字符，双引号字符串

### 例题

**例、以下选项中合法的用户自定义标识符是 ( )**

- (A) `3%`
- (B) `8num`
- (C) `for`
- (D) `_arca3`

**正确答案：D**

**解析：**

| 选项 | 标识符 | 合法性 | 原因 |
|:---:|:---:|:---:|:---|
| A | `3%` | ❌ | 不能以数字开头，且不能包含特殊字符 `%` |
| B | `8num` | ❌ | 不能以数字开头 |
| C | `for` | ❌ | `for` 是关键字/保留字 |
| D | `_arca3` | ✅ | 可以以下划线开头，包含字母、数字和下划线 |

### 常见数据类型所占空间

| 数据类型 | 内存空间 |
|:---|:---:|
| `char` | 1B |
| `short` | 2B |
| `int` `long` `float` | 4B |
| `long long` `double` | 8B |
| 指针 | 4B |

### 输入输出（零碎的知识点比较多，看题）

**回顾：**

- scanf/printf/putchar/getchar 用法？
- 是否读空格/回车？
- 浮点数的输入和输出？
- 转义字符的输出？

**格式说明：**

- `%-m.nf`：左对齐占 m 位保留到 n 位小数

> 对应课本 26～28 页四张表

**例题：** 已有 `int i, j; float x;` 为将 -20 赋给 i，12 赋给 j，410.34 赋给 x；则对应 `scanf("%d,%d,%f",&i,&j,&x)` 调用语句的数据输入形式是 _________

**正确答案：** `-20,12,410.34`

---

## 第三章：运算符与表达式

**重点：**

- 运算符的使用
- 自动类型转换

**难点：**

- 优先级与结合性
- 前置++和后置++的区别

### 表达式求值

- 单变量表达式的值是变量的值
- 赋值表达式的值是 `=` 最右边的值，求值顺序从右到左
- 执行赋值语句，会先计算等号右边的表达式，再将结果赋值给左边的变量
- 运算表达式的值是运算结果，表达式值的类型是表达式中精度最高的值类型

```c
int a = 0;
int b = 0;

a++     // 0
++b     // 1
```

后置 `++` 表达式的值是 a 的值，前置 `++` 表达式的值是 b+1 的值。表达式求值后，a 和 b 的值都会加 1。

### 记忆方式

**离 `=` 更近的是表达式的值**

```c
int a = 0;
int b = 0;

int resultA = a++;      // a  更近 a++的值是a
int resultB = ++b;      // ++ 更近 ++b的值是b+1
```

### 运算符优先级（考前抢记）

```
单目 > 算术 > 位运算 > 逻辑 > 赋值 > 逗号
```

### 逻辑短路

- 对于 `&&`，从左到右遇到第一个值为 0 的表达式，则停止继续求值，并返回 0
- 对于 `||`，从左到右遇到第一个值为 1 的表达式，则停止继续求值，并返回 1

### 自动类型转换

> P46，图 3-2

### 例题

**例、若 x 和 n 均是 int 型变量，且 x 的初值为 12，n 的初值为 5，则执行表达式 `x%=(n%=2)` 后 x 值为 ( )**

- (A) 0
- (B) 6
- (C) 3
- (D) 12

**正确答案：A**

**初始值：**

- x = 12
- n = 5

**表达式：** `x %= (n %= 2)`

**计算步骤：**

1. 先计算括号内的表达式 `n %= 2`
   - `n %= 2` 等价于 `n = n % 2`
   - `n = 5 % 2 = 1`
   - 此时 n 的值变为 1
   - 表达式 `(n %= 2)` 的值为 1

2. 再计算外层表达式 `x %= 1`
   - `x %= 1` 等价于 `x = x % 1`
   - `x = 12 % 1 = 0`
   - 此时 x 的值变为 0

**最终结果：**

- x = 0
- n = 1

---

## 第四章：程序流程控制

**重点：**

- 一层循环案例：累加/累乘
- 二层循环案例：文本打印/排序

**难点：**

- 循环条件设置与次数控制
- for 语句的执行过程
- break 与 continue

### switch-case 语句

（加 break 和不加 break 运行结果的区别）

> 例题：P68，读程序第一题

### 循环语句（很可能读程序写结果）

**例、下面有关 for 循环的正确描述是 ( )**

- (A) for 循环只能用于循环次数已经确定的情况
- (B) for 循环是先执行循环体语句，后判定循环条件是否满足
- (C) 在 for 循环中，不能用 break 语句跳出循环体
- (D) for 循环与 while 循环一样，都是先判断后执行的当型循环

**正确答案：D**

---

**例、以下程序段 ( )**

```c
x=1;
do
{
    x=x*x;
}while(!x);
```

- (A) 是死循环
- (B) 循环体执行二次
- (C) 循环体执行一次
- (D) 有语法错

**正确答案：C**

**执行过程分析：**

1. x = 1
2. 执行 `x = x * x`，x = 1
3. 判断 `!x`，即 `!1 = 0`，条件为假
4. 循环结束

---

## 函数

> 函数：一组一起执行一个任务的语句

### 函数的定义

```c
int foo(int x, int y) // 函数头：函数类型 函数名(参数列表)
{
    /* 函数体 */
    return bar; // 返回值，若函数类型为void则留空
}
```

### 函数的调用

```c
foo(1, 2);  // 常量作为参数
foo(a, b);  // 变量作为参数，也可以是表达式
```

### 函数的声明

```c
int foo(int x, int y);
int foo(int, int);      // 这是由于函数声明的唯一性
int foo(int x, int);    // ←这个奇怪的写法居然也是对的
```

### 参数传递：形参与实参

- 形参是函数中的一个局部变量
- 实参是一个表达式，有一个值
- 调用时使用实参的值初始化形参（复制一份）
- 对于基本数据类型，形参的变化不影响实参涉及的变量

### 例题

**例、若主函数中有定义 `int str[10]={0};` 和函数调用语句 `f(str);`，则下列哪一个函数原型声明是错误的 ( )**

- (A) `void f(int a[]);`
- (B) `void f(int a[5]);`
- (C) `void f(int *a);`
- (D) `void f(int a);`

**正确答案：D**

**逐项分析：**

| 选项 | 声明 | 正确性 | 原因 |
|:---:|:---|:---:|:---|
| A | `void f(int a[]);` | ✅ | 数组作为参数，大小可省略 |
| B | `void f(int a[5]);` | ✅ | 数组大小会被忽略 |
| C | `void f(int *a);` | ✅ | 数组名退化为指针 |
| D | `void f(int a);` | ❌ | 类型不匹配，数组不能传给 int |

---

## 递归

> 套娃

参见"递归"

如果你不知道什么是"递归"，参见"递归"。 ← **注意结束条件**

```c
int f(int x)
{
    if (x == 1) return 1;
    else return (x * f(x-1));
}

f(4)->4*f(3)->4*(3*f(2))->4*(3*(2*f(1)))  // 递
f(4)==24 <- f(3)==6 <- f(2)==2 <- f(1)==1 // 归
```

---

## 变量存储期

- **自动（auto）存储期：** 作用域开始到作用域结束
  - 局部变量：语句块内定义，从定义开始作用到语句块结束，未初始化则为随机值
  - auto 修饰的变量（局部变量默认被 auto 修饰）

- **静态（static）存储期：** 程序开始到程序结束
  - static 修饰的变量
  - 字符串字面量
  - 全局变量：函数体外定义，未初始化则默认为 0

### 例题

**例、下面关于静态局部变量的描述，不正确的是 ( )**

- (A) 静态局部变量只做一次初始化
- (B) 静态局部变量的作用域为整个程序
- (C) 静态局部变量生命期与全局变量相同
- (D) 静态局部变量作用域与自动局部变量相同

**正确答案：B**

**逐项分析：**

| 选项 | 描述 | 正确性 | 说明 |
|:---:|:---|:---:|:---|
| A | 只做一次初始化 | ✅ | static 变量仅初始化一次 |
| B | 作用域为整个程序 | ❌ | **作用域仍在定义的语句块内** |
| C | 生命期与全局变量相同 | ✅ | 都是程序开始到结束 |
| D | 作用域与自动局部变量相同 | ✅ | 都是局部作用域 |

---

## 变量作用域

- **局部作用域：** 局部变量，在语句块内有效
- **全局作用域：** 全局变量、字符串字面量，对整个程序有效

---

## 数组

### 定义与初始化

```c
int a[5];
int a[5] = {1,2,3,4,5};
int a[5] = {1,2,3};       /* a[3]和a[4]默认为0 */
int a[5] = {0};           /* 全都是0 */
int a[] = {1,2,3,4,5};    /* 长度依然为5 */
```

### 访问 —— 从 0 开始

```c
a[0], a[1]
a[5]     // 越界访问
a[-1]    // 越界访问
```

### 二维数组

#### 定义与初始化

```c
int a[3][4];
int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
int a[3][4] = {1,2,3,4,5,6};
int a[3][4] = {{1,2},{3,4},{5,6}};
/* 每个大括号里都是一个一维数组 */
int a[][4]  = {1,2,3,4,5,6,7,8,9,10};
```

#### 访问

```c
a[0][0]
a[2][3]
```

### 多维数组

> 多维数组的本质是数组的数组

### 例题

**例、若有说明：`int a[][4]={{1,2},{3,5},{6,7},{0}};` 则数组 a 的第一维的大小为：__________**

**正确答案：4**

**数组初始化分析：**

```c
int a[][4] = {{1,2},{3,5},{6,7},{0}};
//      ↑ 第二维必须指定
//   ↑ 第一维可省略，由初始化列表确定
```

**初始化列表统计：**

| 行号 | 初始化内容 |
|:---:|:---|
| a[0] | `{1, 2}` → 补齐为 `{1,2,0,0}` |
| a[1] | `{3, 5}` → 补齐为 `{3,5,0,0}` |
| a[2] | `{6, 7}` → 补齐为 `{6,7,0,0}` |
| a[3] | `{0}` → 补齐为 `{0,0,0,0}` |

共 4 行，所以第一维大小 = **4**

**数组存储结构：**

```
       列0  列1  列2  列3
行0  [  1    2    0    0  ]
行1  [  3    5    0    0  ]
行2  [  6    7    0    0  ]
行3  [  0    0    0    0  ]
```

---

## 指针

运算符 `&` 作用于单个变量可以获得它的地址，指针类型变量可以存储一个地址值

**常见的说法：**

- 指针是指针变量的简称
- "指针指向 a" 表示 "指针变量存储变量 a 的地址"

运算符 `*` 作用于指针变量可以访问到指针指向的数据

```c
int a = 0;
int* ptr = &a;
*ptr = 1;
```

### 危险行为

- 不可以访问内存地址为 0，即值为 `NULL` 的数据
- 不可以访问随意给定的内存地址的数据（0x114514）
- 不可以访问未被初始化的指针指向的数据

### 改写变量声明，以增强可读性

**1. 将类型修饰符 `*` 放在类型右边，和变量之间留有一个空格**

```c
int *ptr = &a;
// 改写为
int* ptr = &a;
```

**2. 一句话同时声明多个变量，拆成多个语句，同时注意保留指针类型修饰符 `*`**

```c
int x, y, *ptr1, *ptr2;
// 改写为
int x;
int y;
int* ptr1;
int* ptr2;
```

### const 修饰词语法

- `const` 加在类型前后效果等价
- 对同一类型的 `const` 修饰重复多次等同于一次
- 对于 `const` 修饰指针本身而言，`const` 应移至类型后防止歧义

### * 类型修饰符语法

- `*` 左边的类型是指针所指向的类型

### 例题

**例、设有语句 `int *point, i=10;` 和 `point=&i;`，则下面全部代表地址的一组选项为 ( )**

- (A) `i, point, *&i`
- (B) `&*i, &i, *point`
- (C) `*&point, *point, &i`
- (D) `&i, &*point, point`

**正确答案：D**

**逐项分析：**

| 选项 | 表达式分析 |
|:---:|:---|
| (A) | `i` → 值(10) ❌ / `point` → 地址 ✓ / `*&i` → 值(10) ❌ |
| (B) | `&*i` → 语法错误 ❌ / `&i` → 地址 ✓ / `*point` → 值(10) ❌ |
| (C) | `*&point` → 地址 ✓ / `*point` → 值(10) ❌ / `&i` → 地址 ✓ |
| (D) | `&i` → 地址 ✓ / `&*point` → 地址 ✓ / `point` → 地址 ✓ ✅ |

**等价关系：**

```c
point == &i           // 两者都是i的地址
&*point == &i         // 对指针解引用再取地址，回到原地址
*&i == i              // 对变量取地址再解引用，回到原值
*&point == point      // 对指针取地址再解引用，回到指针本身
```

### 地址偏移

```c
int a[4] = {1, 2, 3, 4};

&a[0] == 100;     // 假设
&a[0] + 1 == 104; // 104 == 100 + sizeof(int) 
&a[0] + 2 == 108; // 108 == 100 + sizeof(int) * 2 
```

**偏移：** 对 T 类型的指针进行 +/- 运算。每加上或减去 1，则地址向后或向前偏移一个 `sizeof(T)`

### 数组名不是指针

对于一个数组的名字 `arr` 而言，其表示数组。`sizeof(arr)` 得到的是数组所占内存空间（即数组长度×数组元素大小）。数组名作为表达式的值是数组首地址，且此表达式的值不可更改。

### [] 运算符

```c
a[0] == *(a + 0);   // a + 0 == 100
a[1] == *(a + 1);   // a + 1 == 104
a[2] == *(a + 2);   // a + 2 == 108
a[3] == *(a + 3);   // a + 3 == 112
a[4] == *(a + 4);   // 越界访问！ a + 4 == 116
```

`[]` 内的数字就是对地址的偏移量

### 查看变量类型技巧

**摘帽子：将变量后缀依次摘掉给类型**

> 下面的写法无法通过编译！仅仅便于我们理解

```c
int arr[][4] = { /*...*/ };
int[4] arr[] = { /*...*/ };     // 'int[4]' is an array
int arr[4][] = { /*...*/ };
int[] arr[4] = { /*...*/ };     // what is 'int[]' ???          
```

### 数组与函数

#### 类型退化

> 类型退化不是考点，是便于我们理解的 C 语言知识点

数组类型作为函数参数时，会发生类型退化

例如：`int arr[5]`，`int arr[]` 都会退化为指针类型 `int*`

---

## 字符串

### 字符串在内存中的存储形式

双引号包围的字符串末尾有字符 `'\0'` 表示字符串结束

```
"hello"
┌─────┬─────┬─────┬─────┬─────┬──────┐
│ 'h' │ 'e' │ 'l' │ 'l' │ 'o' │ '\0' │
└─────┴─────┴─────┴─────┴─────┴──────┘
```

> 整型数字 0 和 字符 `'\0'` 等价

### 为什么可以把字符串复制给 char* 指针？

字符串的本质是字符数组，字符数组经过类型退化后变成了 `char*`，此时指针的值是字符串的首地址。

`"hello"` 存储在内存中的某个特殊区域。可以对它取地址，得到的是字符串首地址。

```c
char* str = "hello"
str == &"hello";
```

注意上面两种赋值方式虽然效果一样，但是原理完全不同。

- 第一行是字符串退化为指针类型，赋值给指针
- 第二行是获得字符串的地址，将它赋值给指针

将字符串赋值给字符数组时会将字符串的每个字符依次复制到数组中

### 字符串处理函数

> 开卷考试请看课本了解这些函数有什么功能以及如何使用，闭卷考试需要考前背诵

```c
strlen(), strcpy(), strcat(), strcmp(), strupr(), strlwr()
```

**注意：** 这些函数的第一个参数是目标字符串

---

## 编译预处理

```c
#include
#define PI 3.14159
#define SUB(a,b) a-b

#ifdef
#else
#endif
#ifndef
#undef
```

### 注意

**`#define` 只完成替换，不执行任何表达式求值**

### 例题

**9、若有宏定义如下：`#define M(x,y) x*y`，则 `M(2+8,4)` 的值是 ( )**

- (A) 40
- (B) 34
- (C) 14
- (D) 16

**正确答案：B**

**宏展开过程：**

```c
#define M(x,y) x*y

M(2+8,4)
↓ 文本替换
2+8*4
↓ 运算符优先级（* 高于 +）
2 + 32
↓
34
```

---

## 结构体

- 初始化方式类似于数组
- 普通变量访问方式 `a.x`
- 结构体指针 `Point *p = &a;`
- 指针访问方式 `p->x` 或 `(*p).x` （注意括号）

### 例题

**例、已知教师记录描述为：**

```c
struct teacher
{
    int id;
    struct {int y; int m; int d;} birth;
} t;
```

将变量 t 中的 d 成员赋值为 25 的语句为：__________

**正确答案：** `t.birth.d = 25;`

**结构体嵌套访问规则：**

```c
struct teacher
{
    int id;                              // 普通成员
    struct {int y; int m; int d;} birth; // 嵌套结构体成员
} t;
```

**结构图示：**

```
t (teacher类型)
├── id
└── birth (匿名结构体)
    ├── y
    ├── m
    └── d  ← 目标成员
```

---

## 文件

### 文件指针 `FILE*`

### 理解记忆

`r w a [ b + ]`（课本 P232 表格）

### 例题

**例、若已存在一个 new.txt 文件，则函数 `fopen("new.txt","w+")` 的功能描述错误的是 ( )**

- (A) 打开 new.txt 文件，消除原有的内容
- (B) 打开 new.txt 文件，可以写入新的内容
- (C) 打开 new.txt 文件，只能读取原有的内容
- (D) 打开 new.txt 文件，可以写入新的内容，也可以读取新写入的内容

**正确答案：C**

**核心知识点：** `"w+"` 模式的特点

- `w` = 写入模式，会清空原有内容
- `+` = 可读可写
- 因此 C 选项"只能读取原有的内容"是错误的

---

## 典型的大题

**例、以下程序的执行结果是 __________**

```c
#include<stdio.h>

int func(int n)
{
    static int m=1;
    do{
        m=m*5+n%10;
        n=n/10;
    }while(n);
    return m;
}

int main()
{
    int n=10;
    printf("%d,",func(n));
    printf("%d\n",func(5));
    return 0;
}
```

**正确答案：** `26,135`

**关键点：** `m` 是 `static` 静态变量，初始化只执行一次，值会保留

### 第一次调用：func(10)

初始状态：m = 1（首次初始化）, n = 10

**循环过程：**

| 次数 | 计算过程 | m值 | n值 |
|:---:|:---|:---:|:---:|
| 1 | m = 1×5 + 10%10 = 5+0 = 5 | 5 | 1 (10/10) |
| 2 | m = 5×5 + 1%10 = 25+1 = 26 | 26 | 0 (1/10) |

n=0, 循环结束，返回值：**26**

### 第二次调用：func(5)

初始状态：m = 26（保留上次的值！）, n = 5
> ↑ static 变量不重新初始化

**循环过程：**

| 次数 | 计算过程 | m值 | n值 |
|:---:|:---|:---:|:---:|
| 1 | m = 26×5 + 5%10 = 130+5 = 135 | 135 | 0 (5/10) |

n=0, 循环结束，返回值：**135**

---

## 回顾课本此章节涉及到的函数

> 开卷考试请看课本了解这些函数有什么功能以及如何使用，闭卷考试需要考前背诵
